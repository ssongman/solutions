# ArgoCD



# 1. 개요

ArgoCD는 **GitOps**를 구현하기 위한 Kubernetes 클러스터의 선언적 애플리케이션 배포 도구이다.  

ArgoCD 설치 및 설정하는 방법에 대해서 가이드한다.



# 2. ArgoCD Install

* 참고링크 : https://argo-cd.readthedocs.io/en/stable/getting_started/



## 1) Install

### (1) Namespace 생성

```sh
# ns 생성
$ kubectl create namespace argocd-system

```



### (2) Install

```sh
# Install (v2.8)
$ kubectl apply -n argocd-system -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml


# 삭제시...
$ kubectl delete -n argocd-system -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

```



#### [참고] 핵심설치

핵심 부분만설치를 원할 경우에는아래와 같이 

```sh
# Install - Onlu core (not contain UI, SSO, Multi-cluster features)
$ kubectl -n argocd-system apply -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/core-install.yaml

```



### (3) 확인

```sh
# 확인

$ kubectl -n argocd-system get svc

NAME                                      TYPE        CLUSTER-IP        EXTERNAL-IP   PORT(S)                      AGE
argocd-applicationset-controller          ClusterIP   192.168.126.121   <none>        7000/TCP,8080/TCP            12s
argocd-dex-server                         ClusterIP   192.168.126.25    <none>        5556/TCP,5557/TCP,5558/TCP   12s
argocd-metrics                            ClusterIP   192.168.126.62    <none>        8082/TCP                     12s
argocd-notifications-controller-metrics   ClusterIP   192.168.126.26    <none>        9001/TCP                     12s
argocd-redis                              ClusterIP   192.168.126.166   <none>        6379/TCP                     12s
argocd-repo-server                        ClusterIP   192.168.126.182   <none>        8081/TCP,8084/TCP            11s
argocd-server                             ClusterIP   192.168.126.103   <none>        80/TCP,443/TCP               11s
argocd-server-metrics                     ClusterIP   192.168.126.66    <none>        8083/TCP                     11s
```



#### [참고] port-forwarding

```sh
# port-forward 로 확인
$ kubectl -n argocd-system port-forward svc/argocd-server 8080:8080

$ curl https://localhost:8080 -i -k
HTTP/1.1 200 OK

```





### (4) deployment insecure 설정

- tls disable 처리
  - deployment 에서 command parameter 로 --insecure 처리
  - 80 port 로 접속이 가능함
  - 대신 ingress 에서 TLS 인증서를 추가할 것이다.

```sh
$ kubectl -n argocd-system edit deploy argocd-server -o yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: argocd-server
  namespace: argocd
...
spec:
  template:
    metadata:
    spec:
      containers:
      - args:
        - /usr/local/bin/argocd-server
        - --insecure                    <--- 삽입
        env:
...
```





# 2. Ingress

## 1) Ingress 생성

```sh
# 
$ cat <<EOF | kubectl -n argocd-system apply -f -
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: argocd-ingress
spec:
  ingressClassName: nginx
  rules:
  - host: argocd.20.249.203.31.nip.io
    http:
      paths:
      - backend:
          service:
            name: argocd-server
            port:
              number: 80
        path: /
        pathType: Prefix
EOF



# 확인
$ curl https://argocd.20.249.203.31.nip.io/ -i -k
HTTP/2 200


```





# 3. ArgoCD 추가 설정



## 1) Argocd CLI 설치



```sh


$ curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
  sudo install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
  rm argocd-linux-amd64


$ argocd version
argocd: v2.12.0+ec30a48
  BuildDate: 2024-08-05T15:31:14Z
  GitCommit: ec30a48bce7a60046836e481cd2160e28c59231d
  GitTreeState: clean
  GoVersion: go1.22.5
  Compiler: gc
  Platform: darwin/arm64



# 통신 잘 안될때  --grpc-web 옵션사용
# argocd 가 reverse proxy 뒤에 있어서...

```



## 2) login



### admin 초기 password 확인

password 기본적으로 자동생성되어 `argocd-initial-admin-secret` 에 보관되어 있다.

간단하게 조회를 원할때는 아래 CLI 명령을 사용한다.

```sh

# password 조회 - argocd 명령으로
$ argocd admin initial-password -n argocd-system
5IFtcjO0xw2OW8Q4


 This password must be only used for first time login. We strongly recommend you update the password using `argocd account update-password`.
---


# password 조회 - kubectl 명령으로...
$ kubectl -n argocd-system get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d; echo


```



### Login

```sh
# < 기본 포멧 >
$ argocd login <ARGOCD_SERVER>


# Login to Argo CD using a username and password
$ argocd login argocd.20.249.203.31.nip.io --grpc-web


# [참고] Login to Argo CD using SSO
$ argocd login argocd.20.249.203.31.nip.io --sso

# [참고] Configure direct access using Kubernetes API server
$ argocd login argocd.20.249.203.31.nip.io --core



# logout
$ argocd logout argocd.20.249.203.31.nip.io
Logged out from 'argocd.20.249.203.31.nip.io'

```



### admin password 변경

```sh
# 비밀번호 update
# login 후에 실행가능
# DEV
$ argocd account update-password \
    --account admin \
    --current-password 5IFtcjO0xw2OW8Q4 \
    --new-password New1234! \
    --grpc-web
Password updated
Context 'argocd.20.249.203.31.nip.io' updated


```





## 3) 사용자

### 사용자 관리

```sh
# 사용자 목록
$ argocd account list
NAME   ENABLED  CAPABILITIES
admin  true     login


# Get specific user details
$ argocd account get --account admin

Name:               admin
Enabled:            true
Capabilities:       login

Tokens:
NONE

```



### 사용자 추가

신규 사용자는 argocd-cm 에서 선언해야 한다.

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: argocd-cm
  namespace: argocd
  labels:
    app.kubernetes.io/name: argocd-cm
    app.kubernetes.io/part-of: argocd
data:
  accounts.alice: apiKey, login
  accounts.alice.enabled: "true"
---


...
data:
  accounts.ssongman: apiKey, login
  accounts.ssongman.enabled: "true"
  accounts.cncorelab: login
  accounts.cncorelab.enabled: "true"
  accounts.diopro: apiKey, login
  accounts.diopro.enabled: "true"
  


```

* 항목 설명
  * apiKey : API 접근을 위한 authentication token 생성을 할 수 있다.
  * login : UI 사용을 위한 login 을 할 수 있다.
  * enabled : User is enabled



#### 목록

```sh
$ argocd account list
NAME       ENABLED  CAPABILITIES
admin      true     login
cncorelab  true     login
ssongman   true     apiKey, login


# 특정유저 상세정보
$ argocd account get --account ssongman
Name:               ssongman
Enabled:            true
Capabilities:       apiKey, login

Tokens:
NONE



```









#### Password

- Set user password

```sh
$ argocd account get --account diopro
Name:               diopro
Enabled:            true
Capabilities:       apiKey, login

Tokens:
NONE



# Set user password
# admin 권한으로 작업시에는 <current-user-password> 는 현재 admin password.


$ argocd account update-password \
  --account <name> \
  --current-password <current-user-password> \
  --new-password <new-user-password>


$ argocd account update-password \
  --account diopro \
  --current-password adminpass \
  --new-password  New1234!
  
Password updated
---


# 변경된 password 는 argocd-secret 에 보관 된다.
# base64 encode 되는 구조가 아니라서 확인은 불가능 하다.


```



### 사용자 삭제

Configmap 에서 삭제한다.

```sh
$ kubectl patch -n argocd-system cm argocd-cm --type='json' -p='[{"op": "remove", "path": "/data/accounts.alice"}]'

```





## 2) Cluster 확인 및 추가



### (1) Cluster 확인

argocd 가 설치되어 있는 Cluster가  in-cluster 라는 이름으로 기본 추가되어 있다.

```sh
# Cluster 목록 확인
$ argocd cluster list
SERVER                          NAME        VERSION  STATUS      MESSAGE  PROJECT
https://kubernetes.default.svc  in-cluster  1.29     Successful
```



### (2) Cluster 추가

만약 또다른 Cluster 를 추가해야 한다면 k8s context 를 이용하는 방법으로 추가할 수 있다.

```sh
# Cluster 목록 확인
$ kubectl config get-contexts -o name
abclab-dev-aks
abclab-prd-aks



# Cluster 추가
$ argocd cluster add abclab-dev-aks

WARNING: This will create a service account `argocd-manager` on the cluster referenced by context `abclab-dev-aks` with full cluster level privileges. Do you want to continue [y/N]? y
INFO[0007] ServiceAccount "argocd-manager" created in namespace "kube-system"
INFO[0007] ClusterRole "argocd-manager-role" created
INFO[0007] ClusterRoleBinding "argocd-manager-role-binding" created
INFO[0007] Created bearer token secret for ServiceAccount "argocd-manager"
Cluster 'https://abclab-dev-abclab-dev-rg-bbe869-appw72du.hcp.koreacentral.azmk8s.io:443' added


```





## 3) Repository 추가

git repo site가 public 일 경우는 repo 등록 없이 사용이 가능하다.

하지만 private 일 겨우 repo 등록해야 한다.

### (1) examples

```sh
# < Format >
$ argocd repo add https://Git주소 --username <계정> --password 로그인 키등록


#####################################################

# < examples >

  # Add a Git repository via SSH using a private key for authentication, ignoring the server's host key:
  argocd repo add git@git.example.com:repos/repo --insecure-ignore-host-key --ssh-private-key-path ~/id_rsa

  # Add a Git repository via SSH on a non-default port - need to use ssh:// style URLs here
  argocd repo add ssh://git@git.example.com:2222/repos/repo --ssh-private-key-path ~/id_rsa

  # Add a private Git repository via HTTPS using username/password and TLS client certificates:
  argocd repo add https://git.example.com/repos/repo --username git --password secret --tls-client-cert-path ~/mycert.crt --tls-client-cert-key-path ~/mycert.key

  # Add a private Git repository via HTTPS using username/password without verifying the server's TLS certificate
  argocd repo add https://git.example.com/repos/repo --username git --password secret --insecure-skip-server-verification

  # Add a public Helm repository named 'stable' via HTTPS
  argocd repo add https://charts.helm.sh/stable --type helm --name stable  

  # Add a private Helm repository named 'stable' via HTTPS
  argocd repo add https://charts.helm.sh/stable --type helm --name stable --username test --password test

  # Add a private Helm OCI-based repository named 'stable' via HTTPS
  argocd repo add helm-oci-registry.cn-zhangjiakou.cr.aliyuncs.com --type helm --name stable --enable-oci --username test --password test

  # Add a private Git repository on GitHub.com via GitHub App
  argocd repo add https://git.example.com/repos/repo --github-app-id 1 --github-app-installation-id 2 --github-app-private-key-path test.private-key.pem

  # Add a private Git repository on GitHub Enterprise via GitHub App
  argocd repo add https://ghe.example.com/repos/repo --github-app-id 1 --github-app-installation-id 2 --github-app-private-key-path test.private-key.pem --github-app-enterprise-base-url https://ghe.example.com/api/v3

  # Add a private Git repository on Google Cloud Sources via GCP service account credentials
  argocd repo add https://source.developers.google.com/p/my-google-cloud-project/r/my-repo --gcp-service-account-key-path service-account-key.json
  
  
```



### (2) github repo 등록

#### repo 등록

https://argo-cd.readthedocs.io/en/stable/user-guide/private-repositories/#access-token



#### personal access token 등록 하는 방법

https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens

```sh
# 30일짜리 personal token( ~ 2023/9/17)
github_pat 


# class token( ~ 2023/9/17)
<token>

# 위 토큰으로 아래처럼 clone시에도 사용가능하다.
$ git clone https://<token>@github.com/ssongman/argocd.git



```









```sh
# repo 목록 확인
$ argocd repo list
# < 없음 >


$ argocd repo add http://gitlab16.diopro.duckdns.org/dio/test/test.git \
    --username root \
    --password New1234!


$ argocd repo list
TYPE  NAME  REPO                                                  INSECURE  OCI    LFS    CREDS  STATUS      MESSAGE  PROJECT
git         http://gitlab16.diopro.duckdns.org/dio/test/test.git  false     false  false  true   Successful


## 삭제시...
$ argocd repo rm http://gitlab16.diopro.duckdns.org/dio/test/test.git




# [참고]===================================

# Add a private Git repository on GitHub.com via GitHub App
$ argocd repo add https://git.example.com/repos/repo --github-app-id 1 --github-app-installation-id 2 --github-app-private-key-path test.private-key.pem


$ argocd repo add https://git.example.com/repos/repo \
    --github-app-id 1 \
    --github-app-installation-id 2 \
    --github-app-private-key-path test.private-key.pem

$ argocd repo add https://github.com/ssongman/argocd.git \
    --username ssongman \
    --password g*****!




```





## 4) Trouble Shooting

### (1) Cluster 배포가 안되는 상황일때

#### 현상

```sh
$ argocd cluster list
SERVER                          NAME        VERSION  STATUS  MESSAGE                                                                                                                                                                                                                                                                                                                                                PROJECT
https://kubernetes.default.svc  in-cluster  1.29     Failed  failed to sync cluster https://192.168.126.1:443: failed to load initial state of resource APIService.apiregistration.k8s.io: apiservices.apiregistration.k8s.io is forbidden: User "system:serviceaccount:argocd-system:argocd-application-controller" cannot list resource "apiservices" in API group "apiregistration.k8s.io" at the cluster scope

```

#### 원인

* ArgoCD의 Application Controller가 Kubernetes 클러스터의 특정 리소스에 접근할 수 없어서 발생한 문제이다.



#### 조치

* ArgoCD **Application Controller**가 필요한 리소스에 접근할 수 있도록 **RBAC(Role-Based Access Control)** 권한을 설정해야 한다.
* 이 권한은 **ClusterRole** 및 **ClusterRoleBinding**을 통해 관리한다.



##### cluster-admin 권한을 부여하는 방법

```sh
$ cat <<EOF | kubectl apply -f -
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: argocd-application-controller-clusterrolebinding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
  - kind: ServiceAccount
    name: argocd-application-controller
    namespace: argocd-system
EOF

# 확인
$ kubectl get ClusterRoleBinding argocd-application-controller-clusterrolebinding
NAME                                               ROLE                        AGE
argocd-application-controller-clusterrolebinding   ClusterRole/cluster-admin   37m



# 삭제시...
$ kubectl delete ClusterRoleBinding argocd-application-controller-clusterrolebinding


```



##### 좀더 세밀한 권한을 만들어 부여하는 방법

```sh
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: argocd-application-controller-clusterrole
rules:
  - apiGroups: ["admissionregistration.k8s.io"]
    resources: ["validatingadmissionpolicybindings"]
    verbs: ["get", "list", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: argocd-application-controller-clusterrolebinding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: argocd-application-controller-clusterrole
subjects:
  - kind: ServiceAccount
    name: argocd-application-controller
    namespace: argocd-system


```



### (2) POD 상태가 보이지 않을때

#### 현상

```sh
argocd UI내 POD에서 Live Manifest 부분에서 아래 에러 발생.

Resource not found in cluster: undefined/undefined:userlist-7b9cd8774-lbl8f

```

#### 원인

* ArgoCD의 argro-server SA가 권한이 없어서 발생



#### 조치

* ArgoCD **argro-server**가 필요한 리소스에 접근할 수 있도록 **RBAC(Role-Based Access Control)** 권한을 설정해야 한다.



##### cluster-admin 권한을 부여하는 방법

```sh
$ cat <<EOF | kubectl apply -f -
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: argocd-serever-clusterrolebinding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
  - kind: ServiceAccount
    name: argocd-server
    namespace: argocd-system
EOF



# 확인
$ kubectl get ClusterRoleBinding argocd-server
NAME            ROLE                        AGE
argocd-server   ClusterRole/argocd-server   19h



# 삭제시...
$ kubectl delete ClusterRoleBinding argocd-server

```







## 5) [참고] Configmap Sample



### (1) argocd-cm

#### samp1_argocd-cm_sample

cat 11.argocd-cm.yaml

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: argocd-cm
  namespace: argocd
  labels:
    app.kubernetes.io/name: argocd-cm
    app.kubernetes.io/part-of: argocd
data:
  # Argo CD's externally facing base URL (optional). Required when configuring SSO
  url: https://argo-cd-demo.argoproj.io

  # Enables application status badge feature
  statusbadge.enabled: "true"

  # Override the Argo CD hostname root URL for both the project and the application status badges.
  # Here is an example of the application status badge for the app `myapp` to see what is replaced.
  #    <statusbadge.url>api/badge?name=myapp&revision=true
  # Provide custom URL to override. You must include the trailing forward slash:
  statusbadge.url: "https://cd-status.apps.argoproj.io/"

  # Enables anonymous user access. The anonymous users get default role permissions specified argocd-rbac-cm.yaml.
  users.anonymous.enabled: "true"
  # Specifies token expiration duration
  users.session.duration: "24h"

  # Specifies regex expression for password
  passwordPattern: "^.{8,32}$"

  # Enables google analytics tracking is specified
  ga.trackingid: "UA-12345-1"
  # Unless set to 'false' then user ids are hashed before sending to google analytics
  ga.anonymizeusers: "false"

  # the URL for getting chat help, this will typically be your Slack channel for support
  help.chatUrl: "https://mycorp.slack.com/argo-cd"
  # the text for getting chat help, defaults to "Chat now!"
  help.chatText: "Chat now!"
  # The URLs to download additional ArgoCD binaries (besides the Linux with current platform binary included by default)
  # for different OS architectures. If provided, additional download buttons will be displayed on the help page.
  help.download.linux-amd64: "path-or-url-to-download"
  help.download.linux-arm64: "path-or-url-to-download"
  help.download.linux-ppc64le: "path-or-url-to-download"
  help.download.linux-s390x: "path-or-url-to-download"
  help.download.darwin-amd64: "path-or-url-to-download"
  help.download.darwin-arm64: "path-or-url-to-download"
  help.download.windows-amd64: "path-or-url-to-download"

  # A dex connector configuration (optional). See SSO configuration documentation:
  # https://github.com/argoproj/argo-cd/blob/master/docs/operator-manual/user-management/index.md#sso
  # https://dexidp.io/docs/connectors/
  dex.config: |
    connectors:
      # GitHub example
      - type: github
        id: github
        name: GitHub
        config:
          clientID: aabbccddeeff00112233
          clientSecret: $dex.github.clientSecret
          orgs:
          - name: your-github-org
            teams:
            - red-team
    # It is possible to provide custom static client for dex if you want to reuse it
    # with other services
    # staticClients:
    # - id: argo-workflow
    #   name: Argo Workflow
    #   redirectURIs:
    #     - https://argo/oauth2/callback
    #   secret: $secretReference

  # OIDC configuration as an alternative to dex (optional).
  oidc.config: |
    name: Okta
    issuer: https://dev-123456.oktapreview.com
    clientID: aaaabbbbccccddddeee
    clientSecret: $oidc.okta.clientSecret
    # Optional set of OIDC scopes to request. If omitted, defaults to: ["openid", "profile", "email", "groups"]
    requestedScopes: ["openid", "profile", "email"]
    # Optional set of OIDC claims to request on the ID token.
    requestedIDTokenClaims: {"groups": {"essential": true}}

  # Configuration to customize resource behavior (optional) can be configured via splitted sub keys.
  # Keys are in the form: resource.customizations.ignoreDifferences.<group_kind>, resource.customizations.health.<group_kind>
  # resource.customizations.actions.<group_kind>, resource.customizations.knownTypeFields.<group-kind>
  # resource.customizations.ignoreResourceUpdates.<group-kind>
  resource.customizations.ignoreDifferences.admissionregistration.k8s.io_MutatingWebhookConfiguration: |
    jsonPointers:
    - /webhooks/0/clientConfig/caBundle
    jqPathExpressions:
    - .webhooks[0].clientConfig.caBundle
    managedFieldsManagers:
    - kube-controller-manager

  # Configuration to define customizations ignoring differences between live and desired states for
  # all resources (GK).
  resource.customizations.ignoreDifferences.all: |
    managedFieldsManagers:
    - kube-controller-manager
    jsonPointers:
    - /spec/replicas

  # Enable resource.customizations.ignoreResourceUpdates rules. If "false," those rules are not applied, and all updates
  # to resources are applied to the cluster cache. Default is false.
  resource.ignoreResourceUpdatesEnabled: "false"

  # Configuration to define customizations ignoring differences during watched resource updates to skip application reconciles.
  resource.customizations.ignoreResourceUpdates.all: |
    jsonPointers:
    - /metadata/resourceVersion

  # Configuration to define customizations ignoring differences during watched resource updates can be configured via splitted sub key.
  resource.customizations.ignoreResourceUpdates.argoproj.io_Application: |
    jsonPointers:
    - /status

  # jsonPointers and jqPathExpressions can be specified.
  resource.customizations.ignoreResourceUpdates.autoscaling_HorizontalPodAutoscaler: |
    jqPathExpressions:
    - '.metadata.annotations."autoscaling.alpha.kubernetes.io/behavior"'
    - '.metadata.annotations."autoscaling.alpha.kubernetes.io/conditions"'
    - '.metadata.annotations."autoscaling.alpha.kubernetes.io/metrics"'
    - '.metadata.annotations."autoscaling.alpha.kubernetes.io/current-metrics"'
    jsonPointers:
    - /metadata/annotations/autoscaling.alpha.kubernetes.io~1behavior
    - /metadata/annotations/autoscaling.alpha.kubernetes.io~1conditions
    - /metadata/annotations/autoscaling.alpha.kubernetes.io~1metrics
    - /metadata/annotations/autoscaling.alpha.kubernetes.io~1current-metrics

  resource.customizations.health.certmanager.k8s.io-Certificate: |
    hs = {}
    if obj.status ~= nil then
      if obj.status.conditions ~= nil then
        for i, condition in ipairs(obj.status.conditions) do
          if condition.type == "Ready" and condition.status == "False" then
            hs.status = "Degraded"
            hs.message = condition.message
            return hs
          end
          if condition.type == "Ready" and condition.status == "True" then
            hs.status = "Healthy"
            hs.message = condition.message
            return hs
          end
        end
      end
    end
    hs.status = "Progressing"
    hs.message = "Waiting for certificate"
    return hs

  resource.customizations.health.cert-manager.io_Certificate: |
    hs = {}
    if obj.status ~= nil then
      if obj.status.conditions ~= nil then
        for i, condition in ipairs(obj.status.conditions) do
          if condition.type == "Ready" and condition.status == "False" then
            hs.status = "Degraded"
            hs.message = condition.message
            return hs
          end
          if condition.type == "Ready" and condition.status == "True" then
            hs.status = "Healthy"
            hs.message = condition.message
            return hs
          end
        end
      end
    end
    hs.status = "Progressing"
    hs.message = "Waiting for certificate"
    return hs

  # List of Lua Scripts to introduce custom actions
  resource.customizations.actions.apps_Deployment: |
    # Lua Script to indicate which custom actions are available on the resource
    discovery.lua: |
      actions = {}
      actions["restart"] = {}
      return actions
    definitions:
      - name: restart
        # Lua Script to modify the obj
        action.lua: |
          local os = require("os")
          if obj.spec.template.metadata == nil then
              obj.spec.template.metadata = {}
          end
          if obj.spec.template.metadata.annotations == nil then
              obj.spec.template.metadata.annotations = {}
          end
          obj.spec.template.metadata.annotations["kubectl.kubernetes.io/restartedAt"] = os.date("!%Y-%m-%dT%XZ")
          return obj

  # Configuration to completely ignore entire classes of resource group/kinds (optional).
  # Excluding high-volume resources improves performance and memory usage, and reduces load and
  # bandwidth to the Kubernetes API server.
  # These are globs, so a "*" will match all values.
  # If you omit groups/kinds/clusters then they will match all groups/kind/clusters.
  # NOTE: events.k8s.io and metrics.k8s.io are excluded by default
  resource.exclusions: |
    - apiGroups:
      - repositories.stash.appscode.com
      kinds:
      - Snapshot
      clusters:
      - "*.local"

  # By default all resource group/kinds are included. The resource.inclusions setting allows customizing
  # list of included group/kinds.
  resource.inclusions: |
    - apiGroups:
      - repositories.stash.appscode.com
      kinds:
      - Snapshot
      clusters:
      - "*.local"

  # An optional comma-separated list of metadata.labels to observe in the UI.
  resource.customLabels: tier

  resource.compareoptions: |
    # if ignoreAggregatedRoles set to true then differences caused by aggregated roles in RBAC resources are ignored.
    ignoreAggregatedRoles: true

    # disables status field diffing in specified resource types
    # 'crd' - CustomResourceDefinitions (default)
    # 'all' - all resources
    # 'none' - disabled
    ignoreResourceStatusField: crd

  # Configuration to add a config management plugin.
  configManagementPlugins: |
    - name: kasane
      init:
        command: [kasane, update]
      generate:
        command: [kasane, show]

  # A set of settings that allow enabling or disabling the config management tool.
  # If unset, each defaults to "true".
  kustomize.enabled: true
  jsonnet.enabled: true
  helm.enabled: true

  # Build options/parameters to use with `kustomize build` (optional)
  kustomize.buildOptions: --load_restrictor none

  # Per-version build options and binary paths
  kustomize.path.v3.9.1: /custom-tools/kustomize_3_9
  kustomize.buildOptions.v3.9.1: --enable_kyaml true

  # Additional Kustomize versions and corresponding binary paths (deprecated)
  kustomize.version.v3.5.1: /custom-tools/kustomize_3_5_1
  kustomize.version.v3.5.4: /custom-tools/kustomize_3_5_4

  # Comma delimited list of additional custom remote values file schemes (http are https are allowed by default).
  # Change to empty value if you want to disable remote values files altogether.
  helm.valuesFileSchemes: http, https

  # The metadata.label key name where Argo CD injects the app name as a tracking label (optional).
  # Tracking labels are used to determine which resources need to be deleted when pruning.
  # If omitted, Argo CD injects the app name into the label: 'app.kubernetes.io/instance'
  application.instanceLabelKey: mycompany.com/appname

  # You can change the resource tracking method Argo CD uses by changing the
  # setting application.resourceTrackingMethod to the desired method.
  # The following methods are available:
  # - label            : Uses the application.instanceLabelKey label for tracking
  # - annotation       : Uses an annotation with additional metadata for tracking instead of the label
  # - annotation+label : Also uses an annotation for tracking, but additionally labels the resource with the application name
  application.resourceTrackingMethod: annotation

  # disables admin user. Admin is enabled by default
  admin.enabled: "false"
  # add an additional local user with apiKey and login capabilities
  #   apiKey - allows generating API keys
  #   login - allows to login using UI
  accounts.alice: apiKey, login
  # disables user. User is enabled by default
  accounts.alice.enabled: "false"

  # The location of optional user-defined CSS that is loaded at runtime.
  # Local CSS Files:
  # - If the supplied path is to a file mounted on the argocd-server container, that file should be mounted
  #   within a subdirectory of the existing "/shared/app" directory (e.g. "/shared/app/custom").  Otherwise,
  #   the file will likely fail to be imported by the browser with an "incorrect MIME type" error.
  # - The path should be specified relative to the "/shared/app" directory; not as an absolute path.
  # Remote CSS Files:
  # - Files may also be loaded from remote locations via fully qualified URLs.
  ui.cssurl: "./custom/my-styles.css"

  # An optional user-defined banner message that's displayed at the top of every UI page.
  # Every time this is updated, it will clear a user's localStorage telling the UI to hide the banner forever.
  ui.bannercontent: "Hello there!"
  # Optional link for banner. If set, the entire banner text will become a link.
  # You can have bannercontent without a bannerurl, but not the other way around.
  ui.bannerurl: "https://argoproj.github.io"
  # Uncomment to make the banner not show the close buttons, thereby making the banner permanent.
  # Because it is permanent, only one line of text is available to not take up too much real estate in the UI,
  # so it is recommended that the length of the bannercontent text is kept reasonably short. Note that you can
  # have either a permanent banner or a regular closeable banner, and NOT both. eg. A user can't dismiss a
  # notification message (closeable) banner, to then immediately see a permanent banner.
  # ui.bannerpermanent: "true"
  # An option to specify the position of the banner, either the top or bottom of the page. The default is at the top.
  # Uncomment to make the banner appear at the bottom of the page. Any value other than "bottom" will make the banner appear at the top.
  # ui.bannerposition: "bottom"

  # Application reconciliation timeout is the max amount of time required to discover if a new manifests version got
  # published to the repository. Reconciliation by timeout is disabled if timeout is set to 0. Three minutes by default.
  # > Note: argocd-repo-server deployment must be manually restarted after changing the setting.
  timeout.reconciliation: 180s

  # cluster.inClusterEnabled indicates whether to allow in-cluster server address. This is enabled by default.
  cluster.inClusterEnabled: "true"

  # Application pod logs RBAC enforcement enables control over who can and who can't view application pod logs.
  # When you enable the switch, pod logs will be visible only to admin role by default. Other roles/users will not be able to view them via cli and UI.
  # When you enable the switch, viewing pod logs for other roles/users will require explicit RBAC allow policies (allow get on logs subresource).
  # When you disable the switch (either add it to the configmap with a "false" value or do not add it to the configmap), no actual RBAC enforcement will take place.
  server.rbac.log.enforce.enable: "false"

  # exec.enabled indicates whether the UI exec feature is enabled. It is disabled by default.
  exec.enabled: "false"

  # exec.shells restricts which shells are allowed for `exec`, and in which order they are attempted
  exec.shells: "bash,sh,powershell,cmd"

  # oidc.tls.insecure.skip.verify determines whether certificate verification is skipped when verifying tokens with the
  # configured OIDC provider (either external or the bundled Dex instance). Setting this to "true" will cause JWT
  # token verification to pass despite the OIDC provider having an invalid certificate. Only set to "true" if you
  # understand the risks.
  oidc.tls.insecure.skip.verify: "false"

  # Add Deep Links to ArgoCD UI
  # sample project level links
  project.links: |
    - url: https://myaudit-system.com?project={{.metadata.name}}
      title: Audit
      description: system audit logs
      icon.class: "fa-book"
  # sample application level links
  application.links: |
    # pkg.go.dev/text/template is used for evaluating url templates
    - url: https://mycompany.splunk.com?search={{.spec.destination.namespace}}
      title: Splunk
    # conditionally show link e.g. for specific project
    # github.com/antonmedv/expr is used for evaluation of conditions
    - url: https://mycompany.splunk.com?search={{.spec.destination.namespace}}
      title: Splunk
      if: spec.project == "default"
    - url: https://{{.metadata.annotations.splunkhost}}?search={{.spec.destination.namespace}}
      title: Splunk
      if: metadata.annotations.splunkhost
  # sample resource level links
  resource.links: |
    - url: https://mycompany.splunk.com?search={{.metadata.namespace}}
      title: Splunk
      if: kind == "Pod" || kind == "Deployment"

  extension.config: |
    extensions:
        # Name defines the endpoint that will be used to register
        # the extension route.
        # Mandatory field.
      - name: some-extension
        backend:
          # ConnectionTimeout is the maximum amount of time a dial to
          # the extension server will wait for a connect to complete.
          # Optional field. Default: 2 seconds
          connectionTimeout: 2s

          # KeepAlive specifies the interval between keep-alive probes
          # for an active network connection between the API server and
          # the extension server.
          # Optional field. Default: 15 seconds
          keepAlive: 15s

          # IdleConnectionTimeout is the maximum amount of time an idle
          # (keep-alive) connection between the API server and the extension
          # server will remain idle before closing itself.
          # Optional field. Default: 60 seconds
          idleConnectionTimeout: 60s

          # MaxIdleConnections controls the maximum number of idle (keep-alive)
          # connections between the API server and the extension server.
          # Optional field. Default: 30
          maxIdleConnections: 30

          services:
              # URL is the address where the extension backend must be available.
              # Mandatory field.
            - url: http://httpbin.org

              # Cluster if provided, will have to match the application
              # destination name or the destination server to have requests
              # properly forwarded to this service URL.
              # Optional field if only one service is specified.
              # Mandatory if multiple services are specified.
              cluster:
                name: some-cluster
                server: https://some-cluster
```



#### samp2

exec.enabled: "true" 등 필요한 부분만 추가한다.

cat > 12.argocd-cm.yaml

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: argocd-cm
  namespace: argocd
  labels:
    app.kubernetes.io/name: argocd-cm
    app.kubernetes.io/part-of: argocd
data:


  # A set of settings that allow enabling or disabling the config management tool.
  # If unset, each defaults to "true".
  kustomize.enabled: "true"
  jsonnet.enabled: "true"
  helm.enabled: "true"



  # disables admin user. Admin is enabled by default
  admin.enabled: "true"
  # add an additional local user with apiKey and login capabilities
  #   apiKey - allows generating API keys
  #   login - allows to login using UI
  accounts.alice: "apiKey, login"
  # disables user. User is enabled by default
  accounts.alice.enabled: "false"


  # cluster.inClusterEnabled indicates whether to allow in-cluster server address. This is enabled by default.
  cluster.inClusterEnabled: "true"


  # exec.enabled indicates whether the UI exec feature is enabled. It is disabled by default.
  exec.enabled: "true"

  # exec.shells restricts which shells are allowed for `exec`, and in which order they are attempted
  exec.shells: "bash,sh,powershell,cmd"


```











# 4. 기타 설정



## 1) Web-based Terminal

참고링크: https://argo-cd.readthedocs.io/en/stable/operator-manual/web_based_terminal/

v2.4 부터 웹 기반 터미널을 제공하여  kubectl exec 와 같은 역할을 수행할 수 있다. 보안을 위해 기본적으로 비활성화 되어 있다.



### (1) `argocd-cm`  exec.enabled 설정

Configmap `argocd-cm` 에서 exec.enabled 키로 설정한다.

```sh
$ kubectl -n argocd-system edit cm argocd-cm
apiVersion: v1
data:
  accounts.82023066: apiKey,login
  accounts.82023066.enabled: "true"
  exec.enabled: "true"                          # <-- true 값으로 추가
  exec.shells: bash,sh,powershell,cmd           # <-- 추가
kind: ConfigMap
metadata:
  annotations:
    kubectl.kubernetes.io/last-applied-configuration: |
      {"apiVersion":"v1","kind":"ConfigMap","metadata":{"annotations":{},"labels":{"app.kubernetes.io/name":"argocd-cm","app.kubernetes.io/part-of":"argocd"},"name":"argocd-cm","namespace":"argocd"}}
  creationTimestamp: "2024-08-08T00:33:03Z"
  labels:
    app.kubernetes.io/name: argocd-cm
    app.kubernetes.io/part-of: argocd
  name: argocd-cm
  namespace: argocd
  resourceVersion: "216723"
  uid: 6f593fc2-26b9-4a09-a5a3-b48d25ded1c5


```



### (2) ClusterRole 설정

 `argocd-server` Role 을 패치해야 한다.

```
- apiGroups:
  - ""
  resources:
  - pods/exec
  verbs:
  - create
```



아래 부분 참고

```sh
$ kubectl -n argocd-system get clusterrole argocd-server -o yaml


$ kubectl -n argocd-system edit clusterrole argocd-server

apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  annotations:
    kubectl.kubernetes.io/last-applied-configuration: |
      {"apiVersion":"rbac.authorization.k8s.io/v1","kind":"ClusterRole","metadata":{"annotations":{},"labels":{"app.kubernetes.io/component":"server","app.kubernetes.io/name":"argocd-server","app.kubernetes.io/part-of":"argocd"},"name":"argocd-server"},"rules":[{"apiGroups":["*"],"resources":["*"],"verbs":["delete","get","patch"]},{"apiGroups":[""],"resources":["events"],"verbs":["list"]},{"apiGroups":[""],"resources":["pods","pods/log"],"verbs":["get"]},{"apiGroups":["argoproj.io"],"resources":["applications"],"verbs":["get","list","watch"]}]}
  creationTimestamp: "2023-08-17T04:07:48Z"
  labels:
    app.kubernetes.io/component: server
    app.kubernetes.io/name: argocd-server
    app.kubernetes.io/part-of: argocd
  name: argocd-server
  resourceVersion: "1405759"
  uid: aa190c30-031c-42bd-b4c5-aba94ec19fe8
rules:
- apiGroups:
  - '*'
  resources:
  - '*'
  verbs:
  - delete
  - get
  - patch
- apiGroups:
  - ""
  resources:
  - events
  verbs:
  - list
- apiGroups:
  - ""
  resources:
  - pods
  - pods/log
  verbs:
  - get
- apiGroups:
  - argoproj.io
  resources:
  - applications
  verbs:
  - get
  - list
  - watch
- apiGroups:                 # <--- 여기부분 추가
  - ""
  resources:
  - pods/exec
  verbs:
  - create


```



### (3) RBAC 조정

exec 리소스를 생성하도록 권한 부여한다. 

```sh
apiVersion: v1
kind: ConfigMap
metadata:
  name: argocd-rbac-cm
  namespace: argocd
data:
  policy.csv: |
    p, role:admin, applications, *, */*, allow
    p, role:admin, clusters, get, *, allow
    p, role:admin, repositories, *, *, allow
    p, role:admin, logs, get, *, allow
    p, role:admin, exec, create, *, allow                 # <--- 여기부분 추가
      
```



### (4) 적용

```sh
# 재기동
$ kubectl -n argocd-system rollout restart deployment argocd-server

```





## 2) RBAC Sample

아래와 같이 설정할 수 있다.

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: argocd-rbac-cm
  namespace: argocd
data:
  policy.default: role:readonly
  policy.csv: |
    p, role:org-admin, applications, *, */*, allow
    p, role:org-admin, clusters, get, *, allow
    p, role:org-admin, repositories, get, *, allow
    p, role:org-admin, repositories, create, *, allow
    p, role:org-admin, repositories, update, *, allow
    p, role:org-admin, repositories, delete, *, allow
    p, role:org-admin, projects, get, *, allow
    p, role:org-admin, projects, create, *, allow
    p, role:org-admin, projects, update, *, allow
    p, role:org-admin, projects, delete, *, allow
    p, role:org-admin, logs, get, *, allow
    p, role:org-admin, exec, create, */*, allow

    g, your-github-org:your-team, role:org-admin

```





# 5. Sample Apps 생성



## 1) App 생성 기본구조



```sh
# App 생성 양식
$ argocd app create $service_name \
    --repo https://Repository주소 \
    --path dist/$service_name/$branch \
    --dest-server $clusterPath \
    --dest-namespace app \
    --upsert


# service_name : Argo에서 관리되는 App이름
# repo : 위에서 등록한 Repository주소
# path : Repository에서 Sync 하위경로, Kubernetes를 배포하기 위한 yaml모음
# dest-server : K8s cluster endpoint주소
# upsert : 이미 등록된 경우 업데이트 수행 (update + insert)



```



#### argocd app list 명령

```sh
# 기본서버 주소 설정
export ARGOCD_SERVER=https://argocd.20.249.203.31.nip.io/


# 확인
$ argocd app list

    

# 확인 - 서버 지정
$ argocd app list \
    --server argocd.20.249.203.31.nip.io



# 확인 - 서버 지정
$ argocd app list \
    --server argocd.20.249.203.31.nip.io
    --insecure


# 기본서버 주소 설정
export ARGOCD_SERVER=argocd.20.249.203.31.nip.io


# 확인
$ argocd app list

```







## 2) sample app

### (1) sample1 guestbook

```sh
# destination ns 준비
$ kubectl create ns yjsong


# argocd 를 현재 namespace로 설정
$ kubectl config set-context --current --namespace=argocd

# argocd login 이후 가능
$ argocd app create guestbook \
    --repo https://github.com/argoproj/argocd-example-apps.git \
    --path guestbook \
    --dest-server https://kubernetes.default.svc \
    --dest-namespace yjsong



# 확인
$ argocd app list --server 172.30.1.31:31981 --grpc-web 


# deploy
$ argocd app sync guestbook


# delete app
$ argocd app delete guestbook

```



### (2) sample2 userlist

```sh
$ argocd app create userlist \
    --project default \
    --repo https://github.com/ssongman/ktds-edu.git \
    --path argocd/userlist \
    --dest-server https://kubernetes.default.svc \
    --dest-namespace yjsong \
    --upsert
    
### 아래는 추가 옵션
    --grpc-web              ## gRPC-web protocol을 사용한다.
                            ## argocd 가 proxy 뒤에 있어서 http2를 지원하지 않을때 유용하다.

# 확인
$ argocd app list

# deploy
$ argocd app sync userlist


# delete app
$ argocd app delete userlist

    
```





### (3) sample2 userlist2

```sh
# 확인
$ argocd app list

# 생성1 - dest-server
$ argocd app create userlist \
    --project default \
    --repo https://github.com/ssongman/argocd.git \
    --path manifest/yaml/userlist \
    --dest-name in-cluster \
    --dest-namespace yjsong
  
# 생성2 - dest-name  
$ argocd app create userlist \
    --project default \
    --repo https://github.com/ssongman/argocd.git \
    --path manifest/yaml/userlist \
    --dest-name in-cluster \
    --dest-namespace yjsong

### 아래는 추가 옵션
    --dest-server https://kubernetes.default.svc   # dest-server or dest-name 둘중 하나 선택가능
    --dest-name in-cluster
    --upsert                ## 동일한 이름의 application 이 존재할때
    --grpc-web              ## gRPC-web protocol을 사용한다.
                            ## argocd 가 proxy 뒤에 있어서 http2 를지원하지 않을때 유용하다.

# 확인
$ argocd app list

# deploy
$ argocd app sync userlist


# delete app
$ argocd app delete userlist

    
```





### (4) sample3 userlist

원격지 배포

```sh
$ argocd app create userlist \
    --project default \
    --repo https://github.com/ssongman/ktds-edu.git \
    --path argocd/userlist \
    --dest-server https://abclab-dev-abclab-dev-rg-bbe869-appw72du.hcp.koreacentral.azmk8s.io:443 \
    --dest-namespace yjsong \
    --upsert


# 확인
$ argocd app list

# deploy
$ argocd app sync userlist


# delete app
$ argocd app delete userlist

```











## 3) rollback

history ID를 참고하여 이전 배포된 버젼으로 rollback 된다.

여기서 배포의 의미는 Sync 를 뜻한다.  즉, argocd UI 에서 수정된 사항들은 history 관리되지 않아 rollback 대상에 포함되지 않는다.

```sh
$ argocd app rollback APPNAME [ID] [flags]


# history
$ argocd app history userlist
ID  DATE                           REVISION
0   2023-08-17 09:00:43 +0000 UTC   (91c7904)
1   2023-08-17 09:06:57 +0000 UTC   (6f86261)
2   2023-08-17 09:15:41 +0000 UTC   (a87e849)




# rollback
# ID 를 지정하지 않으면 바로 직전으로 rollback 된다.
$ argocd app rollback userlist

# history 를 보면 6f86261 의 모습으로 ID 3이 생겼다.
$ argocd app history userlist
ID  DATE                           REVISION
0   2023-08-17 09:00:43 +0000 UTC   (91c7904)
1   2023-08-17 09:06:57 +0000 UTC   (6f86261)
2   2023-08-17 09:15:41 +0000 UTC   (a87e849)
3   2023-08-17 09:16:15 +0000 UTC   (6f86261)



# 이제 특정 ID 로 rollback 해보자.

# rollback
$ argocd app rollback userlist 2

$ argocd app history userlist
ID  DATE                           REVISION
0   2023-08-17 09:00:43 +0000 UTC   (91c7904)
1   2023-08-17 09:06:57 +0000 UTC   (6f86261)
2   2023-08-17 09:15:41 +0000 UTC   (a87e849)
3   2023-08-17 09:16:15 +0000 UTC   (6f86261)
4   2023-08-17 09:18:33 +0000 UTC   (a87e849)



# rollback
$ argocd app rollback userlist


```



==> rollback 은 바로 직전으로 돌아간다.



